#pragma config(Sensor, in1,    left,           sensorLineFollower)
#pragma config(Sensor, in2,    right,          sensorLineFollower)
#pragma config(Sensor, in3,    center,         sensorLineFollower)
#pragma config(Motor,  port2,           m1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           m2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           m4,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           m3,            tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")
//#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_inch)


typedef enum
{
	NO_LINE = 0,
	LINE_CENTER,
	LINE_RIGHT,
	LINE_LEFT,
	LINE_MULTIPLE,
}line_states;

const int line_threshold = 900;
const int spd = 10;
int speed_offset = spd;

line_states state = NO_LINE;

int get_line_binary()
{
	int line_bin[3] = {0,0,0};
	int tempbin = 0;

	if(SensorValue[left] < line_threshold)
	{
		line_bin[0] = 1;
	}
	else
	{
		line_bin[0] =  0;
	}
	if(SensorValue[center] < line_threshold)
	{
		line_bin[1] = 1;
	}
	else
	{
		line_bin[1] =  0;
	}
	if(SensorValue[right] < line_threshold)
	{
		line_bin[2] = 1;
	}
	else
	{
		line_bin[2] =  0;
	}

	tempbin = (line_bin[0] * 100) + (line_bin[1] * 10) + line_bin[2];
	return tempbin;
}

int get_line_state()
{
	int line;

	line = get_line_binary();

	if(100 == line)
	{
		state = LINE_LEFT;
	}
	else if(10 == line)
	{
		state = LINE_CENTER;
	}
	else if(1 == line)
	{
		state = LINE_RIGHT;
	}
	else if(0 == line)
	{
		state = NO_LINE;
	}
	else
	{
		state = LINE_MULTIPLE;
	}

	writeDebugStream("%d\n", line);
	return line;

}

void no_line(int retrace)
{
	motor[m1] = -20;
	motor[m2] = -20;
	motor[m3] = 30;
	motor[m4] = 30;


}
void go_straight()
{
	motor[m1] = 10+speed_offset;
	motor[m2] = 10+speed_offset;
	motor[m3] = 10+speed_offset;
	motor[m4] = 10+speed_offset;

}
//ADD A CORRECTION

void go_left()
{
	motor[m1] = 0;
	motor[m2] = 0;
	motor[m3] = 10+speed_offset;
	motor[m4] = 10+speed_offset;
}
void go_right()
{
	motor[m1] = 10+speed_offset;
	motor[m2] = 10+speed_offset;
	motor[m3] = 0;
	motor[m4] = 0;
}
void decision(int line_bin)
{
	if(110 == line_bin)
	{
		motor[m1] = 5+speed_offset;
		motor[m2] = 5+speed_offset;
		motor[m3] = 15+speed_offset;
		motor[m4] = 15+speed_offset;
	}
	else if (011 == line_bin)
	{
		//rightish
		motor[m1] = 15+speed_offset;
		motor[m2] = 15+speed_offset;
		motor[m3] = 5+speed_offset+10;
		motor[m4] = 5+speed_offset;
	}
	else if (101 == line_bin)
	{
		motor[m1] = 5+speed_offset;
		motor[m2] = 5+speed_offset;
		motor[m3] = 15+speed_offset;
		motor[m4] = 15+speed_offset;
	}
	else
	{
		motor[m1] = 5+speed_offset;
		motor[m2] = 5+speed_offset;
		motor[m3] = 15+speed_offset;
		motor[m4] = 15+speed_offset;
	}
}

task main()
{
	wait1Msec(2000);
	int error;
	line_states prev_state = NO_LINE;

	clearTimer(T1);
	while(true)
	{

		//if(time1[T1]%5000 == 0)
		{
			//speed_offset += 5;
		}
		prev_state = state;
		error = get_line_state();
		if( prev_state != state){
			//motor[m1] = 0;
			//motor[m2] = 0;
			//motor[m3] = 0;
			//motor[m4] = 0;
			clearTimer(T1);
			speed_offset = spd;

		}
		if(NO_LINE == state)
		{
			no_line(prev_state);
		}
		else if(LINE_CENTER == state)
		{
			go_straight();
		}
		else if(LINE_RIGHT == state)
		{
			go_right();
		}
		else if(LINE_LEFT == state)
		{
			go_left();
		}
		else if(LINE_MULTIPLE == state)
		{
			decision(error);
		}
		else
		{
			/*Do Nothing*/
		}
	}

}
